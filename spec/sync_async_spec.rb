# encoding: utf-8

require File.expand_path("../spec_helper", __FILE__)

EM.describe MQ::Queue do
  default_timeout 5

  before do
    @mq = MQ.new
  end

  # Queue.Declare
  should "update MQ::Queue#name by the name generated by the broker" do
    @mq.queue("") do |queue, *args|
      queue.name.should.not.be.empty
      done
    end
  end

  # PENDING: this spec is currently failing
  # https://github.com/tmm1/amqp/issues/issue/31
  should "be able to access message count" do
    name = Array.new(16) { rand(256) }.pack("C*").unpack("H*").first
    exchange = MQ.fanout("fanout")
    @mq.queue!(name) do |queue, *args|
      queue.bind(exchange) do
        3.times { exchange.publish("foobar") }
        # We have 1 channel per 1 MQ instance, so we can just send a sync request
        # and once the requst is finished, we can be sure that the previous one is
        # finished as well. So we can be sure that all the Basic.Publish actions are done.
        @mq.queue!(name) do |queue, message_count, *args|
          message_count.should.eql 3
          done
        end
      end
    end
  end

  # TODO: this will require quite a lot of code, but it should be tested anyway.
  # should "be able to access consumer count" do
  # end

  # Queue.Bind
  should "work with a callback" do
    exchange = MQ.fanout("fanout")
    @mq.queue("") do |queue, *args|
      queue.bind(exchange) do |*args|
        done
      end
    end
  end
end
